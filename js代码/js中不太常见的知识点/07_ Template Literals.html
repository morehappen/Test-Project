<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        //【1】模板字面量在 ES2015 规范中叫做 Template Literals，在规范文档更早的版本中叫 Template Strings;为表述方便也非正式地简称为 ES6 模板。
        // 【1-1】两个反撇号之间的常规字符串保持原样，如：
        function test() {
            `hello world` === "hello world" // --> true
            `hello "world"` === 'hello "world"' // --> true
            `hello 'world'` === "hello 'world'"; // --> true
        }
        // 【1-2】换行符也只是一个字符，因此模板字面量也自然就支持多行字符 
        console.log(`TODO LIST:
            * one
            * two
        `);
        // 【1-2】两个反撇号之间以 ${expression} 格式包含任意 JavaScript 表达式，该 expression 表达式的值会转换为字符串，与表达式前后的字符串拼接。
        // expression 展开为字符串时，使用的是 expression.toString() 函数。
        const name = "Alice";
        const a = 1
        const b = 2
        const fruits = ['apple', 'orange', 'banana']
        const now = new Date()
        console.log(`Hello ${name}`) // Hello Alice
        console.log(`1 + 2 = ${a + b}`) // 1 + 2 = 3
        console.log(`INFO: ${now}`) // INFO: Sun May 13 2018 22:28:26 GMT+0800 (中国标准时间)
        console.log(`Remember to bring: ${ fruits.join(', ') }.`) // Remember to bring: apple, orange, banana.
        console.log(`1 < 2 ${ 1 < 2 ? '✔︎' : '✘'}`); // 1 < 2 ✔︎
        //【1-3】正因为 expression 可以是 任意 JavaScript 表达式 ，而任意一个模板字符串本身也是一个表达式，所以模板中的 expression 可以嵌套另一个模板。
        const fruits1 = ['apple', 'orange', 'banana'];
        const quantities = [4, 5, 6]
        console.log(`I got ${fruits1.map((fruit, index) => `${quantities[index]} ${fruits1}s`).join(', ')}`)
        // I got 4 apple,orange,bananas, 5 apple,orange,bananas, 6 apple,orange,bananas
        //【2】与传统模板引擎对比
    </script>
</body>

</html>